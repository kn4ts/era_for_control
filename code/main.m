clc
close all
clear all

% =============================
%  シミュレーション条件の設定
% =============================
Ts = 0.1 ;	% サンプリング間隔 [s]
Tend  = 10 ;	% シミュレーション時間 [s]
N  = Tend / Ts ;% 繰り返し数の計算

% =============================
%  元のシステムの設定
% =============================
sys.A = [ -0.5572  -0.7814 ;
	   0.7814   0      ];
sys.B = [ 1  -1 ;
	  0   2 ];
sys.C = [ 1.9691  6.4493 ];
sys.D = [ 0  0 ];

% =============================
%  インパルス列の生成
% =============================
u0_h = zeros(2,N);
u0_h(:,1) = [ 1 ; 1 ];	% 初期時刻入力のみ1に設定

% =============================
%  学習データの生成
% =============================
x0   = [ 0; 0 ];	% 状態の初期化
y0_h = drivePlant(sys, x0, u0_h);	% 学習データ生成

% =============================
%  ハンケル行列の計算
% =============================
% - ハンケル行列の次元パラメータ
s = 20 ;
m = 40 ;

% - ハンケル行列の初期化
H  = [];
Hd = [];

% ハンケル行列の計算
for i = 1:s
	H  = [ H  ; y0_h(i:i+m-s-1) ];
	Hd = [ Hd ; y0_h(i+1:i+m-s) ];
end

% =============================
%  ERAの計算
% =============================
% (行列) = PDQ' or USV', 
[  U,  S,  V ] = svd(H);
[ Ud, Sd, Vd ] = svd(Hd);

r  = rank(H);
rd = rank(Hd);

Ur = U(:,1:r);
Vr = V(:,1:r);
Sr = S(1:r,1:r);

% - システム行列の復元
mod.A = pinv(Sr).^0.5 * Ur' * Hd * Vr * pinv(Sr).^0.5
mod.B = Sr.^0.5 * Vr' * [ eye(2) ; zeros(m-s-2,2) ]
mod.C = [ eye(1)  zeros(1,m-s-1) ] * Ur * Sr.^0.5
mod.D = mod.C * mod.B % ? 出力yの初期値から計算? どちらも0でいいかも

% =============================
%  学習モデルの検証
% =============================
% - 学習データと同じ入力に対する応答を計算
y_h = drivePlant(mod, zeros(4,1), u0_h);

% - 結果のプロット
figure(1)
hold on
plot(y_h);
plot(y0_h,':');
legend('learned model by ERA','original signal');
grid on
box on
hold off

function y_h = drivePlant(sys, x0, u_h)
	N = length(u_h) ;
	x = x0 ;
	x_h = zeros(length(x),N) ;
	for i=1:N-1
		x1 = sys.A * x + sys.B * u_h(:,i) ;
		y  = sys.C * x + sys.D * u_h(:,i) ;

		y_h(:,i+1) = y;
		x = x1 ;
	end
end
